```json
{
  "date": "2020.05.09 10:00",
  "tags": ["chan","通道"],
  "description":""
}
```


无缓冲


Go 语言中最常见的、也是经常被人提及的设计模式就是 — 不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存。在很多主流的编程语言中，多个线程传递数据的方式一般都是共享内存，为了解决线程冲突的问题，我们需要限制同一时间能够读写这些变量的线程数量，这与 Go 语言鼓励的方式并不相同。


通道又叫channel，顾名思义，channel的作用就是在多线程之间传递数据的。


们创建了一个无缓冲的channel，然后给这个channel赋值了，程序就是在赋值完成后陷入了死锁。因为我们的channel是无缓冲的，即同步的，赋值完成后来不及读取channel，程序就已经阻塞了。这里介绍一个非常重要的概念：channel的机制是先进先出，如果你给channel赋值了，那么必须要读取它的值，不然就会造成阻塞，当然这个只对无缓冲的channel有效。对于有缓冲的channel，发送方会一直阻塞直到数据被拷贝到缓冲区；如果缓冲区已满，则发送方只能在接收方取走数据后才能从阻塞状态恢复。

这里就不用让主线程休眠了，因为channel在主线程中被赋值后，主线程就会阻塞，直到channel的值在子线程中被取出。

最后我们看一个生产者和消费者的例子：


在这段代码中，因为channel是没有缓冲的，所以当生产者给channel赋值后，生产者这个线程会阻塞，直到消费者线程将channel中的数据取出。消费者第一次将数据取出后，进行下一次循环时，消费者的线程也会阻塞，因为生产者还没有将数据存入，这时程序会去执行生产者的线程。程序就这样在消费者和生产者两个线程间不断切换，直到循环结束。

在这个程序中，缓冲区可以存储10个int类型的整数，在执行生产者线程的时候，线程就不会阻塞，一次性将10个整数存入channel，在读取的时候，也是一次性读取。


异步和同步

https://www.cnblogs.com/xinliangcoder/p/11286801.html

https://www.zhihu.com/question/33306646

https://www.cnblogs.com/shenguanpu/archive/2013/05/05/3060616.html

https://www.cnblogs.com/shenguanpu/archive/2013/05/05/3060616.html

http://blog.zhaojie.me/2013/04/why-channel-and-goroutine-in-golang-are-buildin-libraries-for-other-platforms.html